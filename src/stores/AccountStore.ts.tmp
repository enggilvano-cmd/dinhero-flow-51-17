import { create } from 'zustand'
import { supabase } from '@/integrations/supabase/client'
import { Account, Category, Transaction } from '@/types'

// Tipos do Supabase
interface DBAccount {
  id: string
  name: string
  type: "checking" | "savings" | "credit" | "investment"
  balance: number
  limit_amount: number | null
  due_date: number | null
  closing_date: number | null
  color: string
  user_id: string
  created_at: string
  updated_at: string
}

interface DBCategory {
  id: string
  name: string
  type: "income" | "expense" | "both"
  color: string
  user_id: string
  created_at: string
  updated_at: string
}

interface DBTransaction {
  id: string
  description: string
  amount: number
  date: string
  type: "income" | "expense" | "transfer"
  category_id: string | null
  account_id: string
  status: "pending" | "completed"
  user_id: string
  to_account_id?: string
  installments?: number
  current_installment?: number
  parent_transaction_id?: string
  created_at: string
  updated_at: string
}

interface CreateTransaction {
  description: string
  amount: number
  date: string | Date
  type: 'income' | 'expense' | 'transfer'
  category_id: string
  account_id: string
  status?: 'pending' | 'completed'
  installments?: number
  to_account_id?: string
}

interface CreateTransfer {
  fromAccountId: string
  toAccountId: string
  amount: number
  date: string
}

// Tipos para o estado
export interface AccountStoreState {
  accounts: Account[]
  categories: Category[]
  transactions: Transaction[]
  loading: boolean
  error: string | null
  
  // Funções de carregamento
  loadAccounts: () => Promise<void>
  loadCategories: () => Promise<void>
  loadTransactions: () => Promise<void>
  
  // Funções de contas
  addAccount: (account: Omit<DBAccount, 'created_at' | 'updated_at'>) => Promise<void>
  updateAccount: (account: Partial<DBAccount> & { id: string }) => Promise<void>
  deleteAccount: (id: string) => Promise<void>
  createPayment: (params: { amount: number, accountId: string, date: Date }) => Promise<void>
  createTransfer: (transfer: CreateTransfer) => Promise<void>
  
  // Funções de categorias  
  addCategory: (category: Omit<DBCategory, 'created_at' | 'updated_at'>) => Promise<void>
  updateCategory: (category: Partial<DBCategory> & { id: string }) => Promise<void>
  deleteCategory: (id: string) => Promise<void>
  
  // Funções de transações
  createTransaction: (tx: CreateTransaction) => Promise<void>
  updateTransaction: (tx: Partial<DBTransaction> & { id: string }) => Promise<void>
  deleteTransaction: (id: string) => Promise<void>
  importTransactions: (transactions: Omit<DBTransaction, 'created_at' | 'updated_at' | 'id'>[]) => Promise<void>
}

export const useAccountStore = create<AccountStoreState>((set, get) => ({
  accounts: [],
  categories: [],
  transactions: [],
  loading: false,
  error: null,

  /**
   * Carrega contas do banco de dados.
   * Os saldos (balance, initial_balance) já virão como BIGINT (centavos).
   * O frontend TypeScript os tratará como 'number'.
   */
  loadAccounts: async () => {
    set({ loading: true, error: null })
    try {
      const { data: dbAccounts, error } = await supabase
        .from('accounts')
        .select('*')
        .order('name')

      if (error) throw error
      
      // Converter tipos do DB para tipos da aplicação
      const accounts: Account[] = (dbAccounts || []).map(acc => ({
        id: acc.id,
        name: acc.name,
        type: acc.type,
        balance: acc.balance,
        limit_amount: acc.limit_amount || undefined,
        due_date: acc.due_date || undefined,
        closing_date: acc.closing_date || undefined,
        color: acc.color,
        user_id: acc.user_id
      }))

      set({ accounts })
    } catch (error: any) {
      console.error('Erro ao carregar contas:', error.message)
      set({ error: error.message })
    } finally {
      set({ loading: false })
    }
  },

  /**
   * Carrega categorias do banco de dados.
   */
  loadCategories: async () => {
    set({ loading: true, error: null })
    try {
      const { data: dbCategories, error } = await supabase
        .from('categories')
        .select('*')
        .order('name')

      if (error) throw error
      
      // Converter tipos do DB para tipos da aplicação
      const categories: Category[] = (dbCategories || []).map(cat => ({
        id: cat.id,
        name: cat.name,
        type: cat.type,
        color: cat.color,
        user_id: cat.user_id
      }))

      set({ categories })
    } catch (error: any) {
      console.error('Erro ao carregar categorias:', error.message)
      set({ error: error.message })
    } finally {
      set({ loading: false })
    }
  },

  /**
   * Carrega transações do banco de dados.
   */
  loadTransactions: async () => {
    set({ loading: true, error: null })
    try {
      const { data: dbTransactions, error } = await supabase
        .from('transactions')
        .select('*')
        .order('date', { ascending: false })

      if (error) throw error
      
      // Converter tipos do DB para tipos da aplicação
      const transactions: Transaction[] = (dbTransactions || []).map(tx => ({
        id: tx.id,
        description: tx.description,
        amount: tx.amount,
        date: tx.date,
        type: tx.type,
        category_id: tx.category_id || '',
        account_id: tx.account_id,
        status: tx.status,
        user_id: tx.user_id,
        to_account_id: tx.to_account_id,
        installments: tx.installments,
        current_installment: tx.current_installment,
        parent_transaction_id: tx.parent_transaction_id
      }))

      set({ transactions })
    } catch (error: any) {
      console.error('Erro ao carregar transações:', error.message)
      set({ error: error.message })
    } finally {
      set({ loading: false })
    }
  },

  /**
   * Cria uma nova transação.
   */
  createTransaction: async (tx: CreateTransaction) => {
    try {
      const { error } = await supabase.from('transactions').insert({
        ...tx,
        date: typeof tx.date === 'object' ? tx.date.toISOString().split('T')[0] : tx.date
      })
      if (error) throw error
      get().loadTransactions()
      get().loadAccounts()
    } catch (error: any) {
      console.error('Erro ao criar transação:', error.message)
      throw error
    }
  },

  /**
   * Cria uma transferência
   */
  createTransfer: async (transfer: CreateTransfer) => {
    try {
      const { error } = await supabase.functions.invoke('create-transfer', {
        body: {
          fromAccountId: transfer.fromAccountId,
          toAccountId: transfer.toAccountId,
          amount: transfer.amount,
          date: transfer.date
        }
      })

      if (error) throw error

      // Recarrega as contas para atualizar os saldos
      get().loadAccounts()
      get().loadTransactions()
    } catch (error: any) {
      console.error('Erro ao criar transferência:', error.message)
      throw error
    }
  },

  // Funções de conta
  addAccount: async (account: Omit<DBAccount, 'created_at' | 'updated_at'>) => {
    try {
      const { error } = await supabase.from('accounts').insert(account)
      if (error) throw error
      get().loadAccounts()
    } catch (error: any) {
      console.error('Erro ao adicionar conta:', error.message)
      throw error
    }
  },

  updateAccount: async (account: Partial<DBAccount> & { id: string }) => {
    try {
      const { error } = await supabase
        .from('accounts')
        .update(account)
        .eq('id', account.id)

      if (error) throw error
      get().loadAccounts()
    } catch (error: any) {
      console.error('Erro ao atualizar conta:', error.message)
      throw error
    }
  },

  deleteAccount: async (id: string) => {
    try {
      const { error } = await supabase
        .from('accounts')
        .delete()
        .eq('id', id)

      if (error) throw error
      get().loadAccounts()
    } catch (error: any) {
      console.error('Erro ao excluir conta:', error.message)
      throw error
    }
  },

  createPayment: async ({ amount, accountId, date }: { amount: number, accountId: string, date: Date }) => {
    try {
      const { error } = await supabase.functions.invoke('create-payment', {
        body: {
          amount,
          accountId,
          date: date.toISOString().split('T')[0]
        }
      })

      if (error) throw error
      get().loadAccounts()
    } catch (error: any) {
      console.error('Erro ao criar pagamento:', error.message)
      throw error
    }
  },

  // Funções de categorias
  addCategory: async (category: Omit<DBCategory, 'created_at' | 'updated_at'>) => {
    try {
      const { error } = await supabase.from('categories').insert(category)
      if (error) throw error
      get().loadCategories()
    } catch (error: any) {
      console.error('Erro ao adicionar categoria:', error.message)
      throw error
    }
  },

  updateCategory: async (category: Partial<DBCategory> & { id: string }) => {
    try {
      const { error } = await supabase
        .from('categories')
        .update(category)
        .eq('id', category.id)

      if (error) throw error
      get().loadCategories()
    } catch (error: any) {
      console.error('Erro ao atualizar categoria:', error.message)
      throw error
    }
  },

  deleteCategory: async (id: string) => {
    try {
      const { error } = await supabase
        .from('categories')
        .delete()
        .eq('id', id)

      if (error) throw error
      get().loadCategories()
    } catch (error: any) {
      console.error('Erro ao excluir categoria:', error.message)
      throw error
    }
  },

  // Funções de transações
  updateTransaction: async (tx: Partial<DBTransaction> & { id: string }) => {
    try {
      if (tx.date && tx.date instanceof Date) {
        tx.date = tx.date.toISOString().split('T')[0]
      }

      const { error } = await supabase
        .from('transactions')
        .update(tx)
        .eq('id', tx.id)

      if (error) throw error
      get().loadTransactions()
      get().loadAccounts()
    } catch (error: any) {
      console.error('Erro ao atualizar transação:', error.message)
      throw error
    }
  },

  deleteTransaction: async (id: string) => {
    try {
      const { error } = await supabase
        .from('transactions')
        .delete()
        .eq('id', id)

      if (error) throw error
      get().loadTransactions()
      get().loadAccounts()
    } catch (error: any) {
      console.error('Erro ao excluir transação:', error.message)
      throw error
    }
  },

  importTransactions: async (transactions: Omit<DBTransaction, 'created_at' | 'updated_at' | 'id'>[]) => {
    try {
      const formattedTransactions = transactions.map(tx => ({
        ...tx,
        date: typeof tx.date === 'object' ? tx.date.toISOString().split('T')[0] : tx.date
      }))

      const { error } = await supabase
        .from('transactions')
        .insert(formattedTransactions)

      if (error) throw error
      get().loadTransactions()
      get().loadAccounts()
    } catch (error: any) {
      console.error('Erro ao importar transações:', error.message)
      throw error
    }
  },
}))